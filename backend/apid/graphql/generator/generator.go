package generator

type graphqlFile struct {
	path string
	ast  *ast.Document
}

func newGraphqlFile(path string) graphqlFile {
	file := graphqlFile{}
	file.path = path
	return file
}

func (file *graphqlFile) definitions() []ast.Node {
	if file.ast == nil {
		panic("AST not present; ensure file has been successfully parsed")
	}
	return file.ast.Definitions
}

func (file *graphqlFile) parse() error {
	bin, err := ioutil.ReadFile(file.path)
	if err != nil {
		return err
	}

	params := parser.ParseParams{Source: string(bin)}
	ast, err := parser.Parse(params)
	if err != nil {
		return err
	}

	file.ast = ast
	return nil
}

func (file *graphqlFile) validate() error {
	defs := file.definitions()
	for _, def := range defs { // TODO: Check more than top level?
		switch def.(type) {
		case *ast.OperationDefinition:
			return errors.New("file should not define any operations")
		case *ast.FragmentDefinition:
			return errors.New("file should not define any fragments")
		}
	}
	return nil
}

type generator struct {
	source graphqlFile
	out    *jen.File
}

func newGenerator(pkgName string, source graphqlFile) *generator {
	return &generator{
		source: source,
		out:    jen.NewFile(pkgName),
	}
}

func (g *generator) run() error {
	file := g.out

	// Warning comment
	file.Comment("Code generated by scripts/gengraphql.go. DO NOT EDIT.")
	file.Line()

	// Handle scalar
	// Handle object
	// Handle interface
	// Handle union
	// Handle enum
	// Handle input object
	// Handle directive

	// Generate interface
	// Generate type definition

	outpath := g.source.path + ".go"
	return file.Save(outpath)
}
