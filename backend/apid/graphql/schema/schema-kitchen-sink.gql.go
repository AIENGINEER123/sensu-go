package schema

import (
	context "context"
	graphql "github.com/graphql-go/graphql"
	ast "github.com/graphql-go/graphql/language/ast"
	util "github.com/sensu/sensu-go/backend/apid/graphql/generator/util"
)

// Code generated by graphql/generator package. DO NOT EDIT.

// Schema exposes the root types for each operation.
func Schema() graphql.SchemaConfig {
	return graphql.SchemaConfig{
		Mutation: util.Object("MutationType"),
		Query:    util.Object("QueryType"),
	}
}

//
// FooResolver represents a collection of methods whose products represent the
// response values of the 'Foo' type.
//
//  == Example SDL
//
//    """
//    Dog's are not hooman.
//    """
//    type Dog implements Pet {
//      "name of this fine beast."
//      name:  String!
//
//      "breed of this silly animal; probably shibe."
//      breed: [Breed]
//    }
//
//  == Example generated interface
//
//   // DogResolver ...
//   type DogResolver interface {
//     // Name implements response to request for name field.
//     Name(context.Context, interface{}, graphql.Params) interface{}
//     // Breed implements response to request for breed field.
//     Breed(context.Context, interface{}, graphql.Params) interface{}
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
//  == Example implementation ...
//
//   // MyDogResolver implements DogResolver interface
//   type MyDogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *MyDogResolver) IsTypeOf(r interface{}, p graphql.IsTypeOfParams) interface{} {
//     // ... implementation details ...
//     _, ok := r.(DogGetter)
//     return ok
//   }
type FooResolver interface {
	// one implements response to request for 'One' field.
	One(context.Context, interface{}, graphql.Params) interface{}
	// two implements response to request for 'Two' field.
	Two(context.Context, interface{}, graphql.Params) interface{}
	// three implements response to request for 'Three' field.
	Three(context.Context, interface{}, graphql.Params) interface{}
	// four implements response to request for 'Four' field.
	Four(context.Context, interface{}, graphql.Params) interface{}
	// five implements response to request for 'Five' field.
	Five(context.Context, interface{}, graphql.Params) interface{}
	// six implements response to request for 'Six' field.
	Six(context.Context, interface{}, graphql.Params) interface{}
	// IsTypeOf is used to determine if a given value is associated with the Foo type
	IsTypeOf(context.Context, graphql.IsTypeOfParams) interface{}
}

// Foo is quite the type.
func Foo() graphql.ObjectConfig {
	return graphql.ObjectConfig{
		Description: "Foo is quite the type.",
		Fields: graphql.Fields{
			"five": &graphql.Field{
				Args: graphql.FieldConfigArgument{"argument": &graphql.ArgumentConfig{
					DefaultValue: []interface{}{"string", "string"},
					Description:  "self descriptive",
					Type:         graphql.NewList(graphql.String),
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "five",
				Type:              graphql.String,
			},
			"four": &graphql.Field{
				Args: graphql.FieldConfigArgument{"argument": &graphql.ArgumentConfig{
					DefaultValue: "string",
					Description:  "self descriptive",
					Type:         graphql.String,
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "four",
				Type:              graphql.String,
			},
			"one": &graphql.Field{
				Args:              graphql.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "one is a number.",
				Name:              "one",
				Type:              util.OutputType("Type"),
			},
			"six": &graphql.Field{
				Args: graphql.FieldConfigArgument{"argument": &graphql.ArgumentConfig{
					DefaultValue: map[string]interface{}{"key": "value"},
					Description:  "self descriptive",
					Type:         util.InputType("InputType"),
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "six",
				Type:              util.OutputType("Type"),
			},
			"three": &graphql.Field{
				Args: graphql.FieldConfigArgument{
					"argument": &graphql.ArgumentConfig{
						Description: "self descriptive",
						Type:        util.InputType("InputType"),
					},
					"other": &graphql.ArgumentConfig{
						Description: "self descriptive",
						Type:        graphql.String,
					},
				},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "three",
				Type:              graphql.Int,
			},
			"two": &graphql.Field{
				Args: graphql.FieldConfigArgument{"argument": &graphql.ArgumentConfig{
					Description: "self descriptive",
					Type:        graphql.NewNonNull(util.InputType("InputType")),
				}},
				DeprecationReason: "",
				Description:       "I am told that two is also a number",
				Name:              "two",
				Type:              util.OutputType("Type"),
			},
		},
		Interfaces: []*graphql.Interface{
			util.Interface("Bar")},
		IsTypeOf: func(_ graphql.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see FooResolver.")
		},
		Name: "Foo",
	}
}

//
// AnnotatedObjectResolver represents a collection of methods whose products represent the
// response values of the 'AnnotatedObject' type.
//
//  == Example SDL
//
//    """
//    Dog's are not hooman.
//    """
//    type Dog implements Pet {
//      "name of this fine beast."
//      name:  String!
//
//      "breed of this silly animal; probably shibe."
//      breed: [Breed]
//    }
//
//  == Example generated interface
//
//   // DogResolver ...
//   type DogResolver interface {
//     // Name implements response to request for name field.
//     Name(context.Context, interface{}, graphql.Params) interface{}
//     // Breed implements response to request for breed field.
//     Breed(context.Context, interface{}, graphql.Params) interface{}
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
//  == Example implementation ...
//
//   // MyDogResolver implements DogResolver interface
//   type MyDogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *MyDogResolver) IsTypeOf(r interface{}, p graphql.IsTypeOfParams) interface{} {
//     // ... implementation details ...
//     _, ok := r.(DogGetter)
//     return ok
//   }
type AnnotatedObjectResolver interface {
	// annotatedField implements response to request for 'AnnotatedField' field.
	AnnotatedField(context.Context, interface{}, graphql.Params) interface{}
	// IsTypeOf is used to determine if a given value is associated with the AnnotatedObject type
	IsTypeOf(context.Context, graphql.IsTypeOfParams) interface{}
}

// AnnotatedObject self descriptive
func AnnotatedObject() graphql.ObjectConfig {
	return graphql.ObjectConfig{
		Description: "self descriptive",
		Fields: graphql.Fields{"annotatedField": &graphql.Field{
			Args: graphql.FieldConfigArgument{"arg": &graphql.ArgumentConfig{
				DefaultValue: "default",
				Description:  "self descriptive",
				Type:         util.InputType("Type"),
			}},
			DeprecationReason: "",
			Description:       "self descriptive",
			Name:              "annotatedField",
			Type:              util.OutputType("Type"),
		}},
		Interfaces: []*graphql.Interface{},
		IsTypeOf: func(_ graphql.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedObjectResolver.")
		},
		Name: "AnnotatedObject",
	}
}

//
// BarResolver represents a collection of methods whose products represent the input and
// response values of a interface type.
//
//  == Example generated interface
//
//  // PetResolver ...
//  type PetResolver interface {
//    // ResolveType should return name of type given a value
//    ResolveType(interface{}, graphql.ResolveTypeParams) string
//  }
//
//  // Example implementation ...
//
//  // MyPetResolver implements DateResolver interface
//  type MyPetResolver struct {
//    logger    logrus.LogEntry
//  }
//
//  // ResolveType should return name of type given a value
//  func (r *MyPetResolver) ResolveType(val interface {}, _ graphql.ResolveTypeParams) string {
//    // ... implementation details ...
//    switch pet := val.(type) {
//    when *Dog:
//      return "Dog" // Handled by type identified by 'Dog'
//    when *Cat:
//      return "Cat" // Handled by type identified by 'Cat'
//    }
//    panic("Unimplemented")
//  }
type BarResolver interface {
	// ResolveType should return name of type given a value
	ResolveType(graphql.ResolveTypeParams) *string
}

// Bar self descriptive
func Bar() graphql.InterfaceConfig {
	return graphql.InterfaceConfig{
		Description: "self descriptive",
		Fields: graphql.Fields{
			"four": &graphql.Field{
				Args: graphql.FieldConfigArgument{"argument": &graphql.ArgumentConfig{
					DefaultValue: "string",
					Description:  "self descriptive",
					Type:         graphql.String,
				}},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "four",
				Type:              graphql.String,
			},
			"one": &graphql.Field{
				Args:              graphql.FieldConfigArgument{},
				DeprecationReason: "",
				Description:       "self descriptive",
				Name:              "one",
				Type:              util.OutputType("Type"),
			},
		},
		Name: "Bar",
		ResolveType: func(_ graphql.ResolveTypeParams) *graphql.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see BarResolver.")
		},
	}
}

//
// AnnotatedInterfaceResolver represents a collection of methods whose products represent the input and
// response values of a interface type.
//
//  == Example generated interface
//
//  // PetResolver ...
//  type PetResolver interface {
//    // ResolveType should return name of type given a value
//    ResolveType(interface{}, graphql.ResolveTypeParams) string
//  }
//
//  // Example implementation ...
//
//  // MyPetResolver implements DateResolver interface
//  type MyPetResolver struct {
//    logger    logrus.LogEntry
//  }
//
//  // ResolveType should return name of type given a value
//  func (r *MyPetResolver) ResolveType(val interface {}, _ graphql.ResolveTypeParams) string {
//    // ... implementation details ...
//    switch pet := val.(type) {
//    when *Dog:
//      return "Dog" // Handled by type identified by 'Dog'
//    when *Cat:
//      return "Cat" // Handled by type identified by 'Cat'
//    }
//    panic("Unimplemented")
//  }
type AnnotatedInterfaceResolver interface {
	// ResolveType should return name of type given a value
	ResolveType(graphql.ResolveTypeParams) *string
}

// AnnotatedInterface has stuff
func AnnotatedInterface() graphql.InterfaceConfig {
	return graphql.InterfaceConfig{
		Description: "AnnotatedInterface has stuff",
		Fields: graphql.Fields{"annotatedField": &graphql.Field{
			Args: graphql.FieldConfigArgument{"arg": &graphql.ArgumentConfig{
				Description: "self descriptive",
				Type:        util.InputType("Type"),
			}},
			DeprecationReason: "",
			Description:       "self descriptive",
			Name:              "annotatedField",
			Type:              util.OutputType("Type"),
		}},
		Name: "AnnotatedInterface",
		ResolveType: func(_ graphql.ResolveTypeParams) *graphql.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedInterfaceResolver.")
		},
	}
}

//
// FeedResolver represents a collection of methods whose products represent the
// response values of a union type.
//
//  == Example generated interface
//
//  // FeedResolver ...
//  type FeedResolver interface {
//    // ResolveType should return name of type given a value
//    ResolveType(graphql.ResolveTypeParams) string
//  }
//
//  // Example implementation ...
//
//  // MyFeedResolver implements FeedResolver interface
//  type MyFeedResolver struct {
//    logger    logrus.LogEntry
//  }
//
//  // ResolveType ... TODO
//  func (r *MyFeedResolver) ResolveType(p graphql.ResolveTypeParams) *graphql.Object {
//    // ... implementation details ...
//  }
type FeedResolver interface {
	// ResolveType should return name of type given a value.
	ResolveType(graphql.ResolveTypeParams) string
}

// Feed includes all stuff and things.
func Feed() graphql.UnionConfig {
	return graphql.UnionConfig{
		Description: "Feed includes all stuff and things.",
		Name:        "Feed",
		ResolveType: func(_ graphql.ResolveTypeParams) *graphql.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see FeedResolver.")
		},
		Types: []*graphql.Object{
			util.Object("Story"),
			util.Object("Article"),
			util.Object("Advert")},
	}
}

//
// AnnotatedUnionResolver represents a collection of methods whose products represent the
// response values of a union type.
//
//  == Example generated interface
//
//  // FeedResolver ...
//  type FeedResolver interface {
//    // ResolveType should return name of type given a value
//    ResolveType(graphql.ResolveTypeParams) string
//  }
//
//  // Example implementation ...
//
//  // MyFeedResolver implements FeedResolver interface
//  type MyFeedResolver struct {
//    logger    logrus.LogEntry
//  }
//
//  // ResolveType ... TODO
//  func (r *MyFeedResolver) ResolveType(p graphql.ResolveTypeParams) *graphql.Object {
//    // ... implementation details ...
//  }
type AnnotatedUnionResolver interface {
	// ResolveType should return name of type given a value.
	ResolveType(graphql.ResolveTypeParams) string
}

// AnnotatedUnion i dont care
func AnnotatedUnion() graphql.UnionConfig {
	return graphql.UnionConfig{
		Description: "AnnotatedUnion i dont care",
		Name:        "AnnotatedUnion",
		ResolveType: func(_ graphql.ResolveTypeParams) *graphql.Object {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedUnionResolver.")
		},
		Types: []*graphql.Object{
			util.Object("A"),
			util.Object("B")},
	}
}

//
// CustomScalarResolver represents a collection of methods whose products represent the input and
// response values of a scalar type.
//
//  == Example input SDL
//
//    """
//    Timestamps are great.
//    """
//    scalar Timestamp
//
//  == Example generated interface
//
//    // DateResolver ...
//    type DateResolver interface {
//      // Serialize an internal value to include in a response.
//      Serialize(interface{}) interface{}
//      // ParseValue parses an externally provided value to use as an input.
//      ParseValue(interface{}) interface{}
//      // ParseLiteral parses an externally provided literal value to use as an input.
//      ParseLiteral(ast.Value) interface{}
//    }
//
//  == Example implementation
//
//    // MyDateResolver implements DateResolver interface
//    type MyDateResolver struct {
//      defaultTZ *time.Location
//      logger    logrus.LogEntry
//    }
//
//    // Serialize serializes given date into RFC 943 compatible string.
//    func (r *MyDateResolver) Serialize(val interface{}) interface{} {
//      // ... implementation details ...
//    }
//
//    // ParseValue takes given value and coerces it into an instance of Time.
//    func (r *MyDateResolver) ParseValue(val interface{}) interface{} {
//      // ... implementation details ...
//      // eg. if val is an int use time.At(), if string time.Parse(), etc.
//    }
//
//    // ParseValue takes given value and coerces it into an instance of Time.
//    func (r *MyDateResolver) ParseValue(val ast.Value) interface{} {
//      // ... implementation details ...
//      //
//      // eg.
//      //
//      // if string value return value,
//      // if IntValue Atoi and return value,
//      // etc.
//    }
type CustomScalarResolver interface {
	// Serialize an internal value to include in a response.
	Serialize(interface{}) interface{}
	// ParseValue parses an externally provided value to use as an input.
	ParseValue(interface{}) interface{}
	// ParseLiteral parses an externally provided literal value to use as an input.
	ParseLiteral(ast.Value) interface{}
}

// CustomScalar self descriptive
func CustomScalar() graphql.ScalarConfig {
	return graphql.ScalarConfig{
		Description: "self descriptive",
		Name:        "CustomScalar",
		ParseLiteral: func(_ ast.Value) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see CustomScalarResolver.")
		},
		ParseValue: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see CustomScalarResolver.")
		},
		Serialize: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see CustomScalarResolver.")
		},
	}
}

//
// AnnotatedScalarResolver represents a collection of methods whose products represent the input and
// response values of a scalar type.
//
//  == Example input SDL
//
//    """
//    Timestamps are great.
//    """
//    scalar Timestamp
//
//  == Example generated interface
//
//    // DateResolver ...
//    type DateResolver interface {
//      // Serialize an internal value to include in a response.
//      Serialize(interface{}) interface{}
//      // ParseValue parses an externally provided value to use as an input.
//      ParseValue(interface{}) interface{}
//      // ParseLiteral parses an externally provided literal value to use as an input.
//      ParseLiteral(ast.Value) interface{}
//    }
//
//  == Example implementation
//
//    // MyDateResolver implements DateResolver interface
//    type MyDateResolver struct {
//      defaultTZ *time.Location
//      logger    logrus.LogEntry
//    }
//
//    // Serialize serializes given date into RFC 943 compatible string.
//    func (r *MyDateResolver) Serialize(val interface{}) interface{} {
//      // ... implementation details ...
//    }
//
//    // ParseValue takes given value and coerces it into an instance of Time.
//    func (r *MyDateResolver) ParseValue(val interface{}) interface{} {
//      // ... implementation details ...
//      // eg. if val is an int use time.At(), if string time.Parse(), etc.
//    }
//
//    // ParseValue takes given value and coerces it into an instance of Time.
//    func (r *MyDateResolver) ParseValue(val ast.Value) interface{} {
//      // ... implementation details ...
//      //
//      // eg.
//      //
//      // if string value return value,
//      // if IntValue Atoi and return value,
//      // etc.
//    }
type AnnotatedScalarResolver interface {
	// Serialize an internal value to include in a response.
	Serialize(interface{}) interface{}
	// ParseValue parses an externally provided value to use as an input.
	ParseValue(interface{}) interface{}
	// ParseLiteral parses an externally provided literal value to use as an input.
	ParseLiteral(ast.Value) interface{}
}

// AnnotatedScalar self descriptive
func AnnotatedScalar() graphql.ScalarConfig {
	return graphql.ScalarConfig{
		Description: "self descriptive",
		Name:        "AnnotatedScalar",
		ParseLiteral: func(_ ast.Value) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedScalarResolver.")
		},
		ParseValue: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedScalarResolver.")
		},
		Serialize: func(_ interface{}) interface{} {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see AnnotatedScalarResolver.")
		},
	}
}

// Site self descriptive
func Site() graphql.EnumConfig {
	return graphql.EnumConfig{
		Description: "self descriptive",
		Name:        "Site",
		Values: graphql.EnumValueConfigMap{
			"DESKTOP": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "DESKTOP",
			},
			"MOBILE": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "MOBILE",
			},
		},
	}
}

// Locale self descriptive
func Locale() graphql.EnumConfig {
	return graphql.EnumConfig{
		Description: "self descriptive",
		Name:        "Locale",
		Values: graphql.EnumValueConfigMap{
			"EN": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "Language I know",
				Value:             "EN",
			},
			"HI": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "India",
				Value:             "HI",
			},
			"JA": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "Glorious nippon",
				Value:             "JA",
			},
			"LA": &graphql.EnumValueConfig{
				DeprecationReason: "dead language",
				Description:       "Lanugage I don't know",
				Value:             "LA",
			},
		},
	}
}

// AnnotatedEnum self descriptive
func AnnotatedEnum() graphql.EnumConfig {
	return graphql.EnumConfig{
		Description: "self descriptive",
		Name:        "AnnotatedEnum",
		Values: graphql.EnumValueConfigMap{
			"ANNOTATED_VALUE": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "ANNOTATED_VALUE",
			},
			"OTHER_VALUE": &graphql.EnumValueConfig{
				DeprecationReason: "",
				Description:       "self descriptive",
				Value:             "OTHER_VALUE",
			},
		},
	}
}

// InputType is neato
func InputType() graphql.InputObjectConfig {
	return graphql.InputObjectConfig{
		Description: "InputType is neato",
		Fields: graphql.InputObjectConfigFieldMap{
			"answer": &graphql.InputObjectFieldConfig{
				DefaultValue: "42",
				Description:  "self descriptive",
				Type:         graphql.Int,
			},
			"answr": &graphql.InputObjectFieldConfig{
				DefaultValue: "42",
				Description:  "self descriptive",
				Type:         graphql.Int,
			},
			"key": &graphql.InputObjectFieldConfig{
				Description: "self descriptive",
				Type:        graphql.NewNonNull(graphql.String),
			},
		},
		Name: "InputType",
	}
}

// AnnotatedInput self descriptive
func AnnotatedInput() graphql.InputObjectConfig {
	return graphql.InputObjectConfig{
		Description: "self descriptive",
		Fields: graphql.InputObjectConfigFieldMap{"annotatedField": &graphql.InputObjectFieldConfig{
			Description: "self descriptive",
			Type:        util.InputType("Type"),
		}},
		Name: "AnnotatedInput",
	}
}

//
// NoFieldsResolver represents a collection of methods whose products represent the
// response values of the 'NoFields' type.
//
//  == Example SDL
//
//    """
//    Dog's are not hooman.
//    """
//    type Dog implements Pet {
//      "name of this fine beast."
//      name:  String!
//
//      "breed of this silly animal; probably shibe."
//      breed: [Breed]
//    }
//
//  == Example generated interface
//
//   // DogResolver ...
//   type DogResolver interface {
//     // Name implements response to request for name field.
//     Name(context.Context, interface{}, graphql.Params) interface{}
//     // Breed implements response to request for breed field.
//     Breed(context.Context, interface{}, graphql.Params) interface{}
//     // IsTypeOf is used to determine if a given value is associated with the Dog type
//     IsTypeOf(interface{}, graphql.IsTypeOfParams) bool
//   }
//
//  == Example implementation ...
//
//   // MyDogResolver implements DogResolver interface
//   type MyDogResolver struct {
//     logger logrus.LogEntry
//     store interface{
//       store.BreedStore
//       store.DogStore
//     }
//   }
//
//   // Name implements response to request for name field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     return dog.GetName()
//   }
//
//   // Breed implements response to request for breed field.
//   func (r *MyDogResolver) Name(ctx context.Context, r interface{}, p graphql.Params) interface{} {
//     // ... implementation details ...
//     dog := r.(DogGetter)
//     breed := r.store.GetBreed(dog.GetBreedName())
//     return breed
//   }
//
//   // IsTypeOf is used to determine if a given value is associated with the Dog type
//   func (r *MyDogResolver) IsTypeOf(r interface{}, p graphql.IsTypeOfParams) interface{} {
//     // ... implementation details ...
//     _, ok := r.(DogGetter)
//     return ok
//   }
type NoFieldsResolver interface {
	// IsTypeOf is used to determine if a given value is associated with the NoFields type
	IsTypeOf(context.Context, graphql.IsTypeOfParams) interface{}
}

// NoFields self descriptive
func NoFields() graphql.ObjectConfig {
	return graphql.ObjectConfig{
		Description: "self descriptive",
		Fields:      graphql.Fields{},
		Interfaces:  []*graphql.Interface{},
		IsTypeOf: func(_ graphql.IsTypeOfParams) bool {
			// NOTE:
			// Panic by default. Intent is that when Service is invoked, values of
			// these fields are updated with instantiated resolvers. If these
			// defaults are called it is most certainly programmer err.
			// If you're see this comment then: 'Whoops! Sorry, my bad.'
			panic("Unimplemented; see NoFieldsResolver.")
		},
		Name: "NoFields",
	}
}
