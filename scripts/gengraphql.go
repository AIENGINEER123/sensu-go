package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/Sirupsen/logrus"
	"github.com/dave/jennifer/jen"
	"github.com/jamesdphillips/graphql/language/ast"
	"github.com/jamesdphillips/graphql/language/parser"
)

const (
	packageNameDefault = "schema"
	debuggingDefault   = false
)

var logger = logrus.WithField("component", "graphql-generator")

func main() {
	// Parse
	config := parseArgs(os.Args)

	// Configure logger
	if config.debug {
		logger.Logger.Level = logrus.DebugLevel
		logger.
			WithFields(logrus.Fields{
				"path":         config.path,
				"debug":        config.debug,
				"package-name": config.pkgName,
			}).
			Debug("configured")
	}

	// Find GraphQL files
	files, err := ioutil.ReadDir(config.path)
	if err != nil {
		logger.Fatal(err)
	}
	for i, f := range files {
		if present := strings.HasSuffix(f.Name(), "graphql"); present {
			logger.WithField("file", f.Name()).Debug("graphql file found")
		} else {
			files = append(files[:i], files[i+1:]...)
		}
	}

	// Parse
	logger.Info("parsing .graphql files")
	graphqlFiles := make([]graphqlFile, len(files))
	for i, f := range files {
		filePath := filepath.Join(config.path, f.Name())
		log := logger.WithField("file", f.Name())
		file := newGraphqlFile(filePath)

		if err := file.parse(); err != nil {
			log.WithError(err).Fatal("unable to parse file; check syntax")
		}

		if err := file.validate(); err != nil {
			log.Fatal(err)
		}

		log.Debug("file parsed successfully")
		graphqlFiles[i] = file
	}

	// Generate
	for _, f := range graphqlFiles {
		for i, d := range f.definitions() {
			logEntry := logger.WithField("i", i)
			if d, ok := d.(ast.Node); ok {
				logEntry = logEntry.WithField("kind", d.GetKind())
			}
			// logger.WithField("def", fmt.Sprintf("%#v", d)).Debug("leaf")
			if d, ok := d.(*ast.ObjectDefinition); ok {
				logEntry.WithField("name", d.GetName()).Debug("object def")
				for _, f := range d.Fields {
					logEntry.WithField("name", f.Name).WithField("description", f.Description).Debug("field")
				}
			}
			if d, ok := d.(ast.DescribableNode); ok {
				if desc := d.GetDescription(); desc != nil {
					logEntry.WithField("description", desc.Value).Debug("GetDescription")
				}
			}
		}

		generator := newGenerator(config.pkgName, f)
		if err := generator.run(); err != nil {
			logger.WithError(err).Fatal("unable to generate file")
		}
	}
}

type config struct {
	path    string
	pkgName string
	debug   bool
}

func parseArgs(args []string) config {
	c := config{}

	cmd := flag.NewFlagSet(args[0], flag.ExitOnError)
	cmd.StringVar(&c.pkgName, "P", packageNameDefault, "name of the package")
	cmd.BoolVar(&c.debug, "debug", debuggingDefault, "print debug messages")
	cmd.Usage = func() {
		_, err := fmt.Fprint(os.Stderr, "Usage: gengraphql [OPTIONS] DIRECTORY\n\n")
		if err != nil {
			logger.Fatal("unable to write usage")
		}
		cmd.PrintDefaults()
	}

	if len(args) < 2 {
		cmd.Usage()
		os.Exit(1)
	}

	if err := cmd.Parse(args[1:]); err != nil {
		cmd.Usage()
		os.Exit(1)
	}

	// Ensure directory argument was given
	if cmd.NArg() < 1 {
		cmd.Usage()
		os.Exit(1)
	}

	c.path = cmd.Arg(0)
	return c
}

type graphqlFile struct {
	path string
	ast  *ast.Document
}

func newGraphqlFile(path string) graphqlFile {
	file := graphqlFile{}
	file.path = path
	return file
}

func (file *graphqlFile) definitions() []ast.Node {
	if file.ast == nil {
		panic("AST not present; ensure file has been successfully parsed")
	}
	return file.ast.Definitions
}

func (file *graphqlFile) parse() error {
	bin, err := ioutil.ReadFile(file.path)
	if err != nil {
		return err
	}

	params := parser.ParseParams{Source: string(bin)}
	ast, err := parser.Parse(params)
	if err != nil {
		return err
	}

	file.ast = ast
	return nil
}

func (file *graphqlFile) validate() error {
	defs := file.definitions()
	for _, def := range defs { // TODO: Check more than top level?
		switch def.(type) {
		case *ast.OperationDefinition:
			return errors.New("file should not define any operations")
		case *ast.FragmentDefinition:
			return errors.New("file should not define any fragments")
		}
	}
	return nil
}

type generator struct {
	source graphqlFile
	out    *jen.File
}

func newGenerator(pkgName string, source graphqlFile) *generator {
	return &generator{
		source: source,
		out:    jen.NewFile(pkgName),
	}
}

func (g *generator) run() error {
	file := g.out

	// Warning comment
	file.Comment("Code generated by scripts/gengraphql.go. DO NOT EDIT.")
	file.Line()

	outpath := g.source.path + ".go"
	return file.Save(outpath)
}
